# stitch_trades_with_curve.py  (or whatever file name you used before)

from pathlib import Path
from typing import Optional, List, Dict

import numpy as np
import pandas as pd

import cr_config as cr


def _raw_curve_path_for_month(yymm: str) -> Path:
    """
    Helper: map yymm -> raw tick parquet.

    If you already have a function with this name in your file, KEEP YOUR VERSION
    and delete this stub. Pattern below is just a placeholder.
    """
    # >>> ADJUST IF NEEDED <<<
    # e.g. Path(cr.PATH_DATA) / f"sofr_ticks_{yymm}.parquet"
    return Path(cr.PATH_DATA) / f"raw_{yymm}.parquet"


def _month_key_from_ts(ts: pd.Series) -> pd.Series:
    """Map timestamps to 'yymm' key (e.g. 2023-04-15 -> '2304')."""
    ts = pd.to_datetime(ts, utc=True, errors="coerce")
    return ts.dt.strftime("%y%m")


def attach_curve_to_trades(
    trades_path: str | Path,
    out_path: Optional[str | Path] = None,
) -> pd.DataFrame:
    """
    Attach FULL curve snapshots (all *_mid columns) at each trade's tradetimeUTC.

    Logic:
      1) Load trades.pkl (must have 'tradetimeUTC').
      2) For each yymm:
           - collect unique trade timestamps for that month,
           - load raw tick data for that month from PATH_DATA,
           - reindex curve to those timestamps,
           - drop timestamps with any NaNs (missing curve),
           - merge trimmed curve snapshot onto trades.
      3) Concatenate all monthly results, drop trades whose timestamps
         never matched the curve, and save to out_path (if given).

    Any trade whose tradetimeUTC does NOT exist in the raw curve index
    is dropped (with a warning).
    """
    trades_path = Path(trades_path)
    if out_path is not None:
        out_path = Path(out_path)

    # ------------------------------------------------------------------
    # 1) Load trades and basic sanity
    # ------------------------------------------------------------------
    trades = pd.read_pickle(trades_path)
    if "tradetimeUTC" not in trades.columns:
        raise ValueError("trades must have a 'tradetimeUTC' column.")

    trades = trades.copy()
    trades["tradetimeUTC"] = pd.to_datetime(
        trades["tradetimeUTC"],
        utc=True,
        errors="coerce",
    )

    # Drop blatantly bad timestamps up front
    bad_ts = trades["tradetimeUTC"].isna().sum()
    if bad_ts > 0:
        print(f"[STITCH] Dropping {bad_ts} trades with NaN tradetimeUTC.")
        trades = trades[trades["tradetimeUTC"].notna()].copy()

    if trades.empty:
        raise RuntimeError("No trades left after cleaning tradetimeUTC.")

    # Month key per trade
    trades["yymm"] = _month_key_from_ts(trades["tradetimeUTC"])

    # ------------------------------------------------------------------
    # 2) Month-by-month stitching
    # ------------------------------------------------------------------
    stitched: List[pd.DataFrame] = []
    total_dropped = 0

    for yymm, trades_m in trades.groupby("yymm"):
        trades_m = trades_m.sort_values("tradetimeUTC").copy()
        if trades_m.empty:
            continue

        raw_path = _raw_curve_path_for_month(yymm)
        if not raw_path.exists():
            print(f"[STITCH] Missing raw curve file for {yymm}: {raw_path}. "
                  f"Dropping {len(trades_m)} trades in this month.")
            total_dropped += len(trades_m)
            continue

        curve = pd.read_parquet(raw_path)

        # Ensure curve index is a DateTimeIndex
        if not isinstance(curve.index, pd.DatetimeIndex):
            # Try to promote a time column to index if necessary
            if "ts" in curve.columns:
                curve["ts"] = pd.to_datetime(curve["ts"], utc=True, errors="coerce")
                curve = curve.set_index("ts").sort_index()
            else:
                raise ValueError(
                    f"Raw curve file {raw_path} does not have a DatetimeIndex "
                    "or a 'ts' column to use as index."
                )
        else:
            # Make sure index is timezone-aware UTC to match trades
            if curve.index.tz is None:
                curve.index = curve.index.tz_localize("UTC")
            else:
                curve.index = curve.index.tz_convert("UTC")

        # ------------------------------------------------------------------
        # Unique trade timestamps for this month
        # ------------------------------------------------------------------
        unique_ts = np.sort(trades_m["tradetimeUTC"].unique())

        # Reindex curve to EXACT trade timestamps
        curve_trim = curve.reindex(unique_ts)

        # Detect missing timestamps (any NaN across columns)
        bad_rows = curve_trim.isna().any(axis=1)
        if bad_rows.any():
            bad_count = int(bad_rows.sum())
            good_count = len(curve_trim) - bad_count
            print(
                f"[STITCH] {yymm}: {bad_count} trade timestamps "
                f"have no exact curve row; keeping {good_count}."
            )
            curve_trim = curve_trim[~bad_rows].copy()

        if curve_trim.empty:
            print(f"[STITCH] {yymm}: no trade timestamps matched curve index; "
                  f"dropping {len(trades_m)} trades in this month.")
            total_dropped += len(trades_m)
            continue

        # Keep only trades whose tradetimeUTC is in curve_trim index
        good_ts = curve_trim.index
        trades_good = trades_m[trades_m["tradetimeUTC"].isin(good_ts)].copy()
        dropped_here = len(trades_m) - len(trades_good)
        if dropped_here > 0:
            print(f"[STITCH] {yymm}: dropping {dropped_here} trades "
                  "with non-matching timestamps.")
            total_dropped += dropped_here

        if trades_good.empty:
            continue

        # Prepare curve_trim for merge: bring index back as 'tradetimeUTC'
        idx_name = curve_trim.index.name or "index"
        curve_trim_reset = curve_trim.reset_index().rename(
            columns={idx_name: "tradetimeUTC"}
        )

        # Merge full curve snapshot onto trades
        merged = trades_good.merge(
            curve_trim_reset,
            on="tradetimeUTC",
            how="left",
            validate="many_to_one",
        )

        stitched.append(merged)

    if not stitched:
        raise RuntimeError(
            "No trades could be stitched with the curve. "
            "Check timestamps and raw curve files."
        )

    out = (
        pd.concat(stitched, ignore_index=True)
          .sort_values("tradetimeUTC")
          .reset_index(drop=True)
    )

    if total_dropped > 0:
        print(f"[STITCH] Total trades dropped due to missing curve rows: {total_dropped}")

    # Clean up helper column
    if "yymm" in out.columns:
        out = out.drop(columns=["yymm"])

    # ------------------------------------------------------------------
    # 3) Save & return
    # ------------------------------------------------------------------
    if out_path is not None:
        out_path.parent.mkdir(parents=True, exist_ok=True)
        out.to_pickle(out_path)
        print(f"[STITCH] Wrote stitched trades+curve to: {out_path}")

    return out















from pathlib import Path
from typing import Optional
import pandas as pd
import numpy as np

import cr_config as cr


def _require_cols(df: pd.DataFrame, cols, where: str = ""):
    missing = [c for c in cols if c not in df.columns]
    if missing:
        raise ValueError(f"{where}: missing required columns: {missing}")


def _curve_path_for_yymm(yymm: str) -> Path:
    """
    Find the raw curve file for a given yymm under PATH_DATA.

    Adjust the glob pattern if your raw naming is more specific.
    """
    root = Path(cr.PATH_DATA)
    candidates = list(root.glob(f"*{yymm}*.parquet")) or list(root.glob(f"*{yymm}*.pkl"))
    if not candidates:
        raise FileNotFoundError(f"No raw curve file found under {cr.PATH_DATA} for yymm={yymm}")
    if len(candidates) > 1:
        print(f"[WARN] Multiple raw files for {yymm}, using {candidates[0].name}")
    return candidates[0]


def stitch_trades_with_raw_curve(
    trades: pd.DataFrame,
    *,
    out_path: Optional[str | Path] = None,
) -> pd.DataFrame:
    """
    Stitch raw tick curve mid onto trade tape month-by-month.

    Raw parquet structure:
      - Index: timestamp (tick-level)
      - Columns: '<curve_symbol>_mid' for each curve ticker
        e.g. 'USOSFR5 BGN Curncy_mid' with values like 4.25 for 4.25%.

    Trades:
      - 'tradetimeUTC' : timestamp of trade
      - 'instrument'   : trade instrument (e.g. 'USSWAP5 Curncy')
      - We map instrument -> curve ticker via cr.BBG_DICT.

    Output:
      - Original trade columns +
      - 'curve_symbol' : mapped curve ticker
      - 'curve_ts'     : last tick timestamp <= tradetimeUTC
      - 'curve_mid'    : corresponding mid at curve_ts
    """
    if trades is None or trades.empty:
        raise ValueError("trades is empty; nothing to stitch.")

    _require_cols(trades, ["tradetimeUTC", "instrument"], where="trades")

    df_tr = trades.copy()

    # Parse trade timestamps
    df_tr["tradetimeUTC"] = pd.to_datetime(df_tr["tradetimeUTC"], utc=False, errors="coerce")
    if df_tr["tradetimeUTC"].isna().any():
        bad = df_tr[df_tr["tradetimeUTC"].isna()]
        raise ValueError(
            "Some tradetimeUTC values could not be parsed as datetime. "
            f"Examples:\n{bad.head()}"
        )

    # Map trade instrument -> curve symbol in raw files
    df_tr["curve_symbol"] = df_tr["instrument"].map(cr.BBG_DICT).fillna(df_tr["instrument"])

    # Month bucket (yymm) for per-month processing
    df_tr["yymm"] = df_tr["tradetimeUTC"].dt.strftime("%y%m")

    stitched_chunks: list[pd.DataFrame] = []

    for yymm, trades_month in df_tr.groupby("yymm", sort=True):
        trades_month = trades_month.sort_values("tradetimeUTC").reset_index(drop=True)

        curve_path = _curve_path_for_yymm(yymm)

        if curve_path.suffix.lower() == ".parquet":
            curve = pd.read_parquet(curve_path)
        else:
            curve = pd.read_pickle(curve_path)

        if curve is None or curve.empty:
            print(f"[stitch_trades_with_raw_curve] Empty curve file for {yymm} at {curve_path}")
            continue

        # curve index is the timestamp; normalize
        curve = curve.copy()
        if curve.index.name is None:
            # rename unnamed index to 'curve_ts'
            curve.index.name = "curve_ts"
        curve.index = pd.to_datetime(curve.index, utc=False, errors="coerce")
        curve = curve[~curve.index.isna()]
        if curve.empty:
            print(f"[stitch_trades_with_raw_curve] Curve {curve_path} has no valid timestamps.")
            continue

        # Time window trim for memory
        t_min = trades_month["tradetimeUTC"].min()
        t_max = trades_month["tradetimeUTC"].max()
        curve = curve.loc[t_min - pd.Timedelta("1D") : t_max + pd.Timedelta("1D")]
        if curve.empty:
            print(f"[stitch_trades_with_raw_curve] No curve ticks near trade window for {yymm}.")
            continue

        # For each curve_symbol used this month, do a local merge_asof
        merged_list: list[pd.DataFrame] = []
        symbols_here = trades_month["curve_symbol"].unique().tolist()

        for sym in symbols_here:
            col = f"{sym}_mid"
            trades_sym = trades_month[trades_month["curve_symbol"] == sym].copy()
            if trades_sym.empty:
                continue

            if col not in curve.columns:
                print(f"[stitch_trades_with_raw_curve] No column {col} in {curve_path}; skipping {sym}.")
                # Keep the trades but with NaN for curve_mid / curve_ts
                trades_sym["curve_ts"] = pd.NaT
                trades_sym["curve_mid"] = np.nan
                merged_list.append(trades_sym)
                continue

            # Make a 2-col DataFrame: curve_ts + curve_mid for this symbol
            s = curve[col].dropna()
            if s.empty:
                trades_sym["curve_ts"] = pd.NaT
                trades_sym["curve_mid"] = np.nan
                merged_list.append(trades_sym)
                continue

            df_sym_curve = (
                s.to_frame("curve_mid")
                 .reset_index()
                 .rename(columns={curve.index.name: "curve_ts"})
                 .sort_values("curve_ts")
            )

            trades_sym = trades_sym.sort_values("tradetimeUTC")

            merged_sym = pd.merge_asof(
                trades_sym,
                df_sym_curve,
                left_on="tradetimeUTC",
                right_on="curve_ts",
                direction="backward",
                allow_exact_matches=True,
            )

            merged_list.append(merged_sym)

        if not merged_list:
            continue

        stitched_month = pd.concat(merged_list, ignore_index=True)
        stitched_chunks.append(stitched_month)

    if not stitched_chunks:
        raise RuntimeError(
            "No stitched rows produced. "
            "Check that tradetimeUTC overlaps raw curve files and BBG_DICT mappings."
        )

    stitched = pd.concat(stitched_chunks, ignore_index=True)
    stitched = stitched.sort_values("tradetimeUTC").reset_index(drop=True)
    stitched = stitched.drop(columns=["yymm"], errors="ignore")

    if out_path is not None:
        out_path = Path(out_path)
        out_path.parent.mkdir(parents=True, exist_ok=True)
        if out_path.suffix.lower() == ".pkl":
            stitched.to_pickle(out_path)
        else:
            stitched.to_parquet(out_path, index=False)
        print(f"[stitch_trades_with_raw_curve] Wrote stitched trades to {out_path}")

    return stitched

import pandas as pd
import trade_curve_stitch_raw as tcsr

trades = pd.read_pickle("trades.pkl")

trades_stitched = tcsr.stitch_trades_with_raw_curve(
    trades,
    out_path="trades_with_curve.parquet",
)

trades_stitched[["tradetimeUTC", "instrument", "curve_symbol", "curve_ts", "curve_mid"]].head()